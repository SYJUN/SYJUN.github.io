<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AngularJS-自定义指令]]></title>
    <url>%2F2017%2F08%2F08%2Fangularjs-20170808AngularJS-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[这一篇从自定义指令出发，记录了定义一个指令时影响指令行为的各种因素。试着感受这些因素，让自己更高效地编写AngularJS应用。 Directive 先从定义一个简单的指令开始。 定义一个指令本质上是在HTML中通过元素、属性、类或注释来添加功能。AngularJS 的内置指令都是以 ng 开头，如果想自定义指令，建议自定义一个前缀代表自己的命名空间。这里我们先使用 my 作为前缀: 12345678var myApp = angular.module('myApp', []) .directive('myDirective', function() &#123; return &#123; restrict: 'A', replace: true, template: '&lt;p&gt;Kavlez&lt;/p&gt;' &#125;;&#125;) 如此一来，我们可以这样使用，注意命名是 camel-case : 12&lt;my-directive /&gt;&lt;!-- &lt;my-directive&gt;&lt;p&gt;Kavlez&lt;/p&gt;&lt;/my-directive&gt; --&gt; directive() 接受两个参数 name：字符串，指令的名字 factory_function：函数，指令的行为 应用启动时，以name作为该应用的标识注册factory_function返回的对象。在factory_function中，我们可以设置一些选项来改变指令的行为。 下面记录一下定义指令时用到的选项 restrict （string）该属性用于定义指令以什么形式被使用，这是一个可选参数，本文开头定义的指令用的也是A，其实该选项默认为A。 也就是元素（E）、属性（A）、类（C）、注释（M）(ps:EMAC? EMACS? 挺好记哈)比如上面定义的 myDirective ，可以以任何形式调用。 E（元素） 1&lt;my-directive&gt;&lt;/my-directive&gt; A（属性，默认值） 1&lt;div my-directive="expression"&gt;&lt;/div&gt; C（类名） 1&lt;div class="my-directive:expression;"&gt;&lt;/div&gt; M（注释） 1&lt;--directive:my-directive expression--&gt; priority (Number)也就是优先级，默认为0。在同一元素上声明了多个指令时，根据优先级决定哪个先被调用。 如果 priority 相同，则按声明顺序调用。另外，no-repeat` 是所有内置指令中优先级最高的。 terminal (Boolean)终端? 而且还是Boolean? 被名字吓到了，其实terminal的意思是是否停止当前元素上比该指令优先级低的指令。 但是相同的优先级还是会执行。比如，我们在 my-directive 的基础上再加一个指令: 123456.directive(&apos;momDirective&apos;,function($rootScope)&#123; return&#123; priority:3, terminal:true &#125;;&#125;) 调用发现 my-directive 不会生效: 1&lt;div mom-directive my-directive="content" &gt;&lt;/div&gt; template (String/Function)至少得输出点什么吧? 但template也是可选的。String类型时，template可以是一段HTML。Function类型时，template是一个接受两个参数的函数，分别为： tElement tAttrs函数返回一段字符串作为模板。 templateUrl (String/Function)这个就和上面的template很像了，只不过这次是通过URL请求一个模板。 String类型时，templateURL自然是一个URL。 Function类型时返回一段字符串作为模板URL。 replace (Boolean/String)默认值为false，以文章开头定义的指令为例，假设我们这样调用了指令 1&lt;my-directive&gt;&lt;/my-directive&gt; replace为true时，输出: 1&lt;p&gt;Kavlez&lt;/p&gt; replace为false时，输出: 1&lt;my-directive&gt;&lt;p&gt;Kavlez&lt;/p&gt;&lt;/my-directive&gt; transclude (Boolean)该选项默认为false，翻译过来叫’嵌入’，感觉还是有些生涩。template 和 scope 已经可以做很多事情了，但有一点不足。比如在原有元素的基础上添加内容，transclude 的例子如下: 12345678910111213141516171819202122&lt;body ng-app="myApp"&gt; &lt;textarea ng-model="content"&gt;&lt;/textarea&gt; &lt;div my-directive title="Kavlez"&gt; &lt;hr&gt; &#123;&#123;content&#125;&#125; &lt;/div&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt;var myApp = angular.module('myApp', []).directive('myDirective', function() &#123; return &#123; restrict: 'EA', scope: &#123; title: '@', content: '=' &#125;, transclude: true, template: '&lt;h2 class="header"&gt;&#123;&#123; title &#125;&#125;&lt;/h2&gt;\ &lt;span class="content" ng-transclude&gt;&lt;/span&gt;' &#125;;&#125;);&lt;/script&gt; 发现div下的hr并没有被移除，就是这样的效果。注意不要忘了在模板中声明 ng-transclude 。 scope (Boolean/Object)默认为false，true时会从父作用域继承并创建一个自己的作用域。而 ng-controller 的作用也是从父作用域继承并创建一个新的作用域。比如这样，离开了自己的作用域就被打回原形了: 123456789101112131415161718&lt;div ng-init="content='from root'"&gt; &#123;&#123;content&#125;&#125; &lt;div ng-controller="AncestorController"&gt; &#123;&#123;content&#125;&#125; &lt;div ng-controller="ChildController"&gt; &#123;&#123;content&#125;&#125; &lt;/div&gt; &#123;&#123;content&#125;&#125; &lt;/div&gt; &#123;&#123;content&#125;&#125; &lt;/div&gt;.controller('ChildController', function($scope) &#123; $scope.content = 'from child';&#125;).controller('AncestorController', function($scope) &#123; $scope.content = 'from ancestor';&#125;) 但不要误解，指令嵌套并不一定会改变它的作用域。既然 true 时会从父作用域继承并创建一个自己的作用域，那么我们来试试改为 false 会是什么样子: 12345678910111213&lt;div ng-init="myProperty='test'"&gt; &#123;&#123; myProperty &#125;&#125; &lt;div my-directive ng-init="myProperty = 'by my-directive'"&gt; &#123;&#123; myProperty &#125;&#125; &lt;/div&gt; &#123;&#123; myProperty &#125;&#125;&lt;/div&gt;.directive('myDirective', function($rootScope) &#123; return &#123; scope:false &#125;;&#125;) 显然，结果是三行’by my-directive’。非true即false? naive!其实最麻烦的还是隔离作用域， 我们稍微改动一下myDirective，改为输出 &lt;p&gt;&lt;/p&gt; 。于是我试着这样定义: 123456789101112131415161718192021222324&lt;body ng-app="myApp" &gt; &lt;p ng-controller="myController"&gt; &lt;div my-directive="I have to leave." &gt;&lt;/div&gt; &#123;&#123;myDirective&#125;&#125; &lt;/p&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt;var myApp = angular.module('myApp', []).directive('myDirective', function($rootScope) &#123; $rootScope.myDirective = 'from rootScope'; return &#123; priority:1000, restrict: 'A', replace: true, scope: &#123; myDirective: '@', &#125;, template: '&lt;p&gt;&#123;&#123;myDirective&#125;&#125;&lt;/p&gt;' &#125;;&#125;).controller('myController',function($scope)&#123; $scope.myDirective = 'from controller';&#125;);&lt;/script&gt; 这里需要注意的不是 @ ，重点是隔离作用域。根据上面的例子输出，template中的 不会影响到其他作用域。我们再试试这样: 12345&lt;input type="text" ng-model="content"&gt;&lt;p ng-controller="myController" &gt;&lt;div my-directive="&#123;&#123;content&#125;&#125;" &gt;&lt;/div&gt; &#123;&#123;content&#125;&#125;&lt;/p&gt; 发现大家都在一起变，也就是说值是通过复制DOM属性并传递到隔离作用域。 ng-model 是个强大的指令，它将自己的隔离作用域和DOM作用域连在一起，这样就是一个双向数据绑定。 如何向指令的隔离作用域中传递数据，这里用了 @ 。或者也可以写成 @myDirective ，也就是说换个名字什么的也可以，比如我用 @myCafe 什么的给 myDirective 赋值也是没问题的，总之是和DOM属性进行绑定。 另外，我们也可以用 = 进行双向绑定，将本地作用域的属性同父级作用域的属性进行双向绑定。比如下面的例子中，隔离作用域里的内容只能是’abc’ : 123456789101112131415161718192021222324&lt;body ng-app="myApp" ng-init="content='abc'"&gt; &lt;p ng-controller="myController" &gt; &lt;input type="text" ng-model="content"&gt; &lt;div my-directive="content" &gt;&lt;/div&gt; &#123;&#123;content&#125;&#125; &lt;/p&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt;var myApp = angular.module('myApp', []).directive('myDirective', function($rootScope) &#123; return &#123; priority:1000, restrict: 'A', replace: true, scope: &#123; myDirective: '=', &#125;, template: '&lt;p&gt;from myDirective:&#123;&#123;myDirective&#125;&#125;&lt;/p&gt;' &#125;;&#125;) .controller('myController',function($scope)&#123; $scope.content = 'from controller';&#125;);&lt;/script&gt; 在隔离作用域访问指令外部的作用域的方法还有一种，就是 &amp; 。我们可以使用 &amp; 与父级作用域的函数进行绑定，比如下面的例子: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;body ng-app="myApp"&gt; &lt;div ng-controller="myController"&gt; &lt;table border='1'&gt; &lt;tr&gt; &lt;td&gt;From&lt;/td&gt; &lt;td&gt;&lt;input type="text" ng-model="from"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;To&lt;/td&gt; &lt;td&gt;&lt;input type="text" ng-model="to"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Content&lt;/td&gt; &lt;td&gt;&lt;textarea cols="30" rows="10" ng-model="content"&gt;&lt;/textarea&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Preview:&lt;/td&gt; &lt;td&gt;&lt;div scope-example to="to" on-send="sendMail(content)" from="from" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt;var myApp = angular.module('myApp', []).controller('myController',function($scope)&#123; $scope.sendMail=function(content)&#123; console.log('content is:::'+content); &#125;&#125;).directive('scopeExample',function()&#123; return&#123; restrict:'EA', scope: &#123; to: '=', from: '=' , send: '&amp;onSend' &#125;, template:'&lt;div&gt;From:&#123;&#123;from&#125;&#125;&lt;br&gt;\ To:&#123;&#123;to&#125;&#125;&lt;br&gt;\ &lt;button ng-click="send()"&gt;Send&lt;/button&gt;\ &lt;/div&gt;' &#125;&#125;)&lt;/script&gt; controller (String/Function)控制器也可以在指令里定义，比如: 123456.directive(&apos;myDirective&apos;, function() &#123; restrict: &apos;A&apos;, controller: &apos;myController&apos;&#125;).controller(&apos;myController&apos;, function($scope, $element, $attrs,$transclude) &#123; //...&#125;) 相同的效果，也可以这样声明: 123456directive(&apos;myDirective&apos;, function() &#123; restrict: &apos;A&apos;, controller:function($scope, $element, $attrs, $transclude) &#123; //... &#125;&#125;); controllerAs (String)可以从名字和类型看出，这个选项是用来设置控制器的别名的。 比如这样: 12345678910directive(&apos;myDirective&apos;, function() &#123; return &#123; restrict: &apos;A&apos;, template: &apos;&lt;p&gt;&#123;&#123; myController.name &#125;&#125;&lt;/p&gt;&apos;, controllerAs: &apos;myController&apos;, controller: function() &#123; this.name = &quot;Kavlez&quot; &#125; &#125;;&#125;); compile (Object/Function)虽说这个东西不是很常用吧，但却是值得了解的选项。 compile 和 link ，这两个选项关系到AngularJS的生命周期。 先在这里简单记录一下我对生命周期的认识。 应用启动前，所有的指令以文本的形式存在。 应用启动后便开始进行compile和link，DOM开始变化，作用域与HTML进行绑定。 在编译阶段，AngularJS会遍历整个HTML并处理已声明的指令。 一个指令的模板中可能使用了另外一个指令，这个指令的模板中可能包含其他指令，如此层层下来便是一个模板树。 在DOM尚未进行数据绑定时对DOM进行操作开销相对较小，这时像ng-repeat之类的指令对DOM进行操作则再合适不过了。 我们可以用编译函数访问编译后的DOM，在数据绑定之前用编译函数对模板DOM进行转换，编译函数会返回模板函数。 也就是说，设置compile函数的意义在于:在指令和实时数据被放到DOM中之前修改DOM。 此时完全可以毫无顾虑地操作DOM。 接着我们便可以进入下一个阶段，链接阶段。 最后，模板函数传递给指令指定的链接函数，链接函数对作用域和DOM进行链接。 好了，接下来我们就试试compile: 12345678910111213141516171819&lt;body ng-app="myApp"&gt; &lt;my-directive ng-model="myName"&gt;&lt;/my-directive&gt;&lt;/body&gt;&lt;script type="text/javascript"&gt;var myApp = angular.module('myApp', []).directive('myDirective', function($rootScope) &#123; $rootScope.myName = 'Kavlez'; return &#123; restrict: 'EA', compile:function(tEle, tAttrs, transcludeFn) &#123; var h2 = angular.element('&lt;h2&gt;&lt;/h2&gt;'); h2.attr('type', tAttrs.type); h2.attr('ng-model', tAttrs.ngModel); h2.html("hello &#123;&#123;"+tAttrs.ngModel+"&#125;&#125;"); tEle.replaceWith(h2); &#125; &#125;;&#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>directive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 运行机制详解: Event Loop]]></title>
    <url>%2F2017%2F07%2F17%2Fjavascript-20170717javascript-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6-Event-Loop%2F</url>
    <content type="text"><![CDATA[为什么JavaScript是单线程？JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。 JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。 任务队列单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。 如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。 JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。 于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。） 1.所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 2.主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 3.一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 4.主线程不断重复上面的第三步。 下图就是主线程和任务队列的示意图。 只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。这个过程会不断重复。 事件和回调函数“任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。 “任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。 所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。 “任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。 Event Loop主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。 为了更好地理解Event Loop，请看下图 上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。 执行栈中的代码（同步任务），总是在读取”任务队列”（异步任务）之前执行。请看下面这个例子。 123456var req = new XMLHttpRequest();req.open('GET', url); req.onload = function ()&#123;&#125;; req.onerror = function ()&#123;&#125;; req.send(); 上面代码中的req.send方法是Ajax操作向服务器发送数据，它是一个异步任务，意味着只有当前脚本的所有代码执行完，系统才会去读取”任务队列”。所以，它与下面的写法等价。 123456var req = new XMLHttpRequest();req.open('GET', url);req.send();req.onload = function ()&#123;&#125;; req.onerror = function ()&#123;&#125;; 也就是说，指定回调函数的部分（onload和onerror），在send()方法的前面或后面无关紧要，因为它们属于执行栈的一部分，系统总是执行完它们，才会去读取”任务队列”。 定时器除了放置异步任务的事件，”任务队列”还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫做”定时器”（timer）功能，也就是定时执行的代码。 定时器功能主要由setTimeout()和setInterval()这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。以下主要讨论setTimeout()。 setTimeout()接受两个参数，第一个是回调函数，第二个是推迟执行的毫秒数。 123456console.log(1);setTimeout(function()&#123;console.log(2);&#125;,1000);console.log(3);// 上面代码的执行结果是1，3，2，// 因为setTimeout()将第二行推迟到1000毫秒之后执行。 如果将setTimeout()的第二个参数设为0，就表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。 12345setTimeout(function()&#123;console.log(1);&#125;, 0);console.log(2);// 上面代码的执行结果总是2，1，// 因为只有在执行完第二行以后，系统才会去执行"任务队列"中的回调函数。 总之，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。 HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout()。 需要注意的是，setTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。 Node.js的Event LoopNode.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。 请看下面的示意图 根据上图，Node.js的运行机制如下。 1.V8引擎解析JavaScript脚本。 2.解析后的代码，调用Node API。 3.libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。 4.V8引擎再将结果返回给用户。 除了setTimeout和setInterval这两个方法，Node.js还提供了另外两个与”任务队列”有关的方法：process.nextTick和setImmediate。它们可以帮助我们加深对”任务队列”的理解。 process.nextTick方法可以在当前”执行栈”的尾部—-下一次Event Loop（主线程读取”任务队列”）之前—-触发回调函数。也就是说，它指定的任务总是发生在所有异步任务之前。setImmediate方法则是在当前”任务队列”的尾部添加事件，也就是说，它指定的任务总是在下一次Event Loop时执行，这与setTimeout(fn, 0)很像。请看下面的例子。 1234567891011process.nextTick(function A() &#123; console.log(1); process.nextTick(function B()&#123;console.log(2);&#125;);&#125;);setTimeout(function timeout() &#123; console.log('TIMEOUT FIRED');&#125;, 0)// 1// 2// TIMEOUT FIRED 上面代码中，由于process.nextTick方法指定的回调函数，总是在当前”执行栈”的尾部触发，所以不仅函数A比setTimeout指定的回调函数timeout先执行，而且函数B也比timeout先执行。这说明，如果有多个process.nextTick语句（不管它们是否嵌套），将全部在当前”执行栈”执行。 现在，再看setImmediate。 12345678setImmediate(function A() &#123; console.log(1); setImmediate(function B()&#123;console.log(2);&#125;);&#125;);setTimeout(function timeout() &#123; console.log('TIMEOUT FIRED');&#125;, 0); 上面代码中，setImmediate与setTimeout(fn,0)各自添加了一个回调函数A和timeout，都是在下一次Event Loop触发。那么，哪个回调函数先执行呢？答案是不确定。运行结果可能是1–TIMEOUT FIRED–2，也可能是TIMEOUT FIRED–1–2。 令人困惑的是，Node.js文档中称，setImmediate指定的回调函数，总是排在setTimeout前面。实际上，这种情况只发生在递归调用的时候。 12345678910111213setImmediate(function ()&#123; setImmediate(function A() &#123; console.log(1); setImmediate(function B()&#123;console.log(2);&#125;); &#125;); setTimeout(function timeout() &#123; console.log('TIMEOUT FIRED'); &#125;, 0);&#125;);// 1// TIMEOUT FIRED// 2 上面代码中，setImmediate和setTimeout被封装在一个setImmediate里面，它的运行结果总是1–TIMEOUT FIRED–2，这时函数A一定在timeout前面触发。至于2排在TIMEOUT FIRED的后面（即函数B在timeout后面触发），是因为setImmediate总是将事件注册到下一轮Event Loop，所以函数A和timeout是在同一轮Loop执行，而函数B在下一轮Loop执行。 我们由此得到了process.nextTick和setImmediate的一个重要区别：多个process.nextTick语句总是在当前”执行栈”一次执行完，多个setImmediate可能则需要多次loop才能执行完。事实上，这正是Node.js 10.0版添加setImmediate方法的原因，否则像下面这样的递归调用process.nextTick，将会没完没了，主线程根本不会去读取”事件队列”！ 123process.nextTick(function foo() &#123; process.nextTick(foo);&#125;); 事实上，现在要是你写出递归的process.nextTick，Node.js会抛出一个警告，要求你改成setImmediate。 另外，由于process.nextTick指定的回调函数是在本次”事件循环”触发，而setImmediate指定的是在下次”事件循环”触发，所以很显然，前者总是比后者发生得早，而且执行效率也高（因为不用检查”任务队列”）。 转自:阮一峰老师的《JavaScript 运行机制详解：再谈Event Loop》]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Event Loop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.gitconfig 常用配置]]></title>
    <url>%2F2017%2F07%2F15%2Fgit-20170715gitconfig-%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[开发一个项目肯定少不了项目版本管理工具，有了它我们就可以更加方便快捷的管理项目，以前用的是图形化的 svn ，但是自从用了 git 后,就果断放弃了 svn ，没别的，只觉得 git 分布式的管理方式更加好用。但是在项目中使用 git 如果总是敲完整的命令总是觉得太麻烦了，所以就在自己找了一些个人喜欢的配置，最后总结出来。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152[alias] co = checkout ci = commit st = status pl = pull ps = push d = diff dic = diff --cached dih = diff HEAD cp = cherry-pick ca = commit -a br = branch rb = branch -r dl = diff master HEAD do = diff origin/master HEAD unstage = reset HEAD -- mg = merge --no-ff last = log -l HEAD rih = rebase -i HEAD lost = reflog prepush = log --graph --stat origin/master l = log --color --graph --format=format:&apos;%C(bold blue)%h%C(reset): %C(bold green)(%ad)%C(reset) %C(bold yellow)&lt;%an&gt;%C(reset)%C(bold red)%d%C(reset)%n&apos;&apos; %C(reset)%s%C(reset)&apos; --date=local --abbrev-commit lg = log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit --all[user] name = yourName email = yourName@email.com[color] branch = auto diff = auto status = auto ui = true[color &quot;branch&quot;] current = blue reverse local = green remote = red[color &quot;diff&quot;] meta = yellow bold frag = magenta bold old = red bold new = green bold[color &quot;status&quot;] added = green changed = red untracked = cyan[pull] rebase = true[core] excludesfile = /Users/mac/.gitignore_global]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生js实现实时监听输入的文本]]></title>
    <url>%2F2017%2F07%2F14%2Fjavascript-20170714%E5%8E%9F%E7%94%9Fjs%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E7%9B%91%E5%90%AC%E8%BE%93%E5%85%A5%E7%9A%84%E6%96%87%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[以前只是在一些 mvc、mvvm 框架(angular、vue等)中使用 双向数据绑定 实现将文本区域中显示的内容显示在指定的区域。现在我使用原生 DOM 来模拟这种效果。首先简单设计一个简单的页面布局 1234&lt;div class="test-wrap"&gt; &lt;textarea id="testWatch" placeholder="请输入..."&gt;&lt;/textarea&gt; &lt;div id='showTxt' class="showTxt"&gt;&lt;/div&gt;&lt;/div&gt; 然后再设置一些样式整体美化一下(入了前端的坑,有强迫症了…o_o) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* 定义keyframe动画，命名为blink */@keyframes blinkCursor &#123; 0% &#123; opacity: 1; &#125; 50% &#123; opacity: 1; &#125; 50.01% &#123; opacity: 0; &#125; /* 注意这里定义50.01%立刻透明度为０，可以设置闪烁效果 */ 100% &#123; opacity: 0; &#125; &#125;// 简单初始化页面样式* &#123; padding: 0; margin: 0; &#125;textarea:focus &#123; outline: none; &#125;.test-wrap &#123; textarea &#123; display: block; height: 40px; border: 1px solid #ccc; border-radius: 5px; padding: 5px 10px; width: 140px; margin: 10px auto; resize: none; &amp;:focus &#123; border-color: #ff9052; &#125; &#125; .showTxt &#123; width: 130px; height: auto; min-height: 200px; background-color: #f2f2f2; padding: 10px 15px; color: #666; border: 1px solid #ccc; margin: 0 auto; word-break: break-all; &amp;:after &#123; content: ''; width: 2px; height: 15px; display: inline-block; vertical-align: middle; border-right: 2px solid #ff9052; /* 定义 blinkCursor 类*/ animation: blinkCursor .75s linear infinite; color: #dd4814; &#125; &#125;&#125; 样式添加好了,现在来添加js,实现我们想要的效果: 1234567891011121314151617const $addEvent = function (elem, eType, fn, useCapture)&#123; if (elem.addEventListener) &#123; elem.addEventListener(eType, fn, useCapture); return true; &#125; else if (elem.attachEvent) &#123; var r = elem.attachEvent('on' + eType, fn); return r; &#125; else &#123; elem['on' + eType] = fn; &#125;&#125;const element = document.getElementById('testWatch');$addEvent(element, 'input', () =&gt; &#123; document.getElementById("showTxt").innerHTML = element.value;&#125;, false); 好了,这样就已经实现我们想要的效果了 实例地址 See the Pen 实时显示文本框中输入的内容 by syjun (@SYJUN) on CodePen.]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[display flex 布局教程]]></title>
    <url>%2F2017%2F07%2F14%2FHTML-CSS-20170714display-flex-%E5%B8%83%E5%B1%80%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[布局的传统解决方案，基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现 Flex布局是什么？Flex 是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局。 12345678910.box1&#123; display: flex; &#125; .box2&#123; display: inline-flex; /* 行内元素也可以使用Flex布局。 */&#125; .box3&#123; display: -webkit-flex; /* Safari ,Webkit内核的浏览器，必须加上-webkit前缀。*/ display: flex; &#125; 注意，设为 Flex 布局以后，子元素的 float 、 clear 和 vertical-align 属性将失效。 基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性 flex-direction flex-wrap flex-flow justify-content align-items align-content flex-direction属性flex-direction 属性决定主轴的方向（即项目的排列方向）。 123.box &#123; flex-direction: row | row-reverse | column | column-reverse; &#125; row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。 flex-wrap 属性定义，如果一条轴线排不下，如何换行。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse; &#125; nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 flex-flowflex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。 123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; &#125; justify-content属性justify-content 属性定义了项目在主轴上的对齐方式。 123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around; &#125; flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items属性align-items 属性定义项目在交叉轴上如何对齐 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch; &#125; flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content属性align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch; &#125; flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self order属性order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 123.item &#123; order: &lt;integer&gt;; &#125; flex-grow属性flex-grow 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */ &#125; 如果所有项目的 flex-grow 属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的 flex-grow 属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性flex-shrink 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */ &#125; 如果所有项目的 flex-shrink 属性都为1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink 属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 flex-basis属性flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */ &#125; 它可以设为跟 width 或 height 属性一样的值（比如350px），则项目将占据固定空间。 flex属性flex 属性是 flex-grow , flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto 。后两个属性可选。 123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ] &#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self属性align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto ，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch 。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch; &#125; 该属性可能取6个值，除了 auto ，其他都与 align-items 属性完全一致。]]></content>
      <categories>
        <category>HTML+CSS</category>
      </categories>
      <tags>
        <tag>flex布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[$.ajax() 的 data 参数类型]]></title>
    <url>%2F2017%2F07%2F13%2Fjquery-20170713ajax-%E7%9A%84data%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[假如现在有这样一个表单，是添加元素用的。 123456&lt;form id='addForm' action='UserAdd.action' type='post'&gt; &lt;label for='uname'&gt;用户名&lt;/label&gt;：&lt;input type='text' name='uname' id='uname'&gt;&lt;br&gt; &lt;label for='mobileIpt'&gt;手机号：&lt;/label&gt;&lt;input type='text' name='mobileIpt' id='mobileIpt'&gt;&lt;br&gt; &lt;label for='birthday'&gt;生日：&lt;/label&gt;&lt;input type='text' name='birthday'&gt;&lt;br&gt; &lt;input type='button' value='提交' onclick='addUser()'&gt;&lt;/form&gt; 我们不想使用表单submit的方式添加这个元素，我们就想使用ajax提交。 以前我们是这样实现的： 123456789101112131415161718192021function addUser()&#123; var user = &#123; uname:$("#uname").val(), mobileIpt:$("#mobileIpt").val(), birthday:$("#birthday").val() &#125;; $.ajax(&#123; url:'UserAdd.action', data:user, type:'post', dataType:'text', success:function(msg)&#123; if(msg=='1')&#123; console.log('添加成功'); &#125;else&#123; console.log('添加失败') &#125; &#125; &#125;)&#125; 这没有什么错，就是获取表单元素的值实在是太麻烦….这里只有三项，很多项的时候就废了…. 直到有一天，我发现了jquery的serializeArray方法 序列化表格元素 (类似 ‘.serialize()’ 方法) 返回 JSON 数据结构数据。 注意，此方法返回的是JSON对象而非JSON字符串。需要使用插件或者第三方库进行字符串化操作。 返回的JSON对象是由一个对象数组组成的，其中每个对象包含一个或两个名值对——name参数和value参数（如果value不为空的话）。 我们来试试看 1234567$('#addForm').serializeArray();//返回数据结构，是json数组，每个对像分别name和value为key，代表这个表单元素的name和value[ &#123;"name":"uname","value":""&#125;, &#123;"name":"mobileIpt","value":""&#125;, &#123;"name":"birthday","value":""&#125;] 这个貌似用不上啊 我们使用JQuery.param()方法处理一下： 1234var arr = $('#addForm').serializeArray();$.param(arr);// "uname=alice&amp;mobileIpt=110&amp;birthday=1983-05-12" 嘿这下符合我们的需求了吧，虽然不是json类型，但是至少可以作为data上传了。 这里我们可以直接在ajax的data处填上这个json数组，在jquery内部自己调用$.param()处理的。 我们来看下jquery.param()方法的说明： 1234567891011121314// 返回值:StringjQuery.param(obj,[traditional])// 将表单元素数组或者对象序列化。/*参数obj,[traditional]数组或jQuery对象会按照name/value对进行序列化，普通对象按照key/value对进行序列化。traditional:是否使用传统的方式浅层序列化。*/// demo:$.param(&#123;uanme:'vic',mobileIpt:'110',birthday:'2013-11-11'&#125;);// "uanme=vic&amp;mobileIpt=110&amp;birthday=2013-11-11" 看着说明，貌似也跟我们没关系啊,我们换一个json数组来看 123$.param([&#123;uanme:'vic'&#125;,&#123;mobileIpt:'110'&#125;,&#123;birthday:'2013-11-11'&#125;]);// "undefined=&amp;undefined=&amp;undefined=" 这个转换不成功了吧，为什么我们表单的那种数据能够成功转换成url参数呢？我们来看下jquery源码 12345678910111213141516171819//在ajax()方法中，对json类型的数据进行了$.param()处理if ( s.data &amp;&amp; s.processData &amp;&amp; typeof s.data !== "string" ) &#123; s.data = jQuery.param( s.data, s.traditional );&#125;//param方法中if ( jQuery.isArray( a ) || ( a.jquery &amp;&amp; !jQuery.isPlainObject( a ) ) ) &#123; // Serialize the form elements jQuery.each( a, function() &#123; add( this.name, this.value ); &#125;);&#125; else &#123; // If traditional, encode the "old" way (the way 1.3.2 or older // did it), otherwise encode params recursively. for ( prefix in a ) &#123; buildParams( prefix, a[ prefix ], traditional, add ); &#125;&#125; 这下明白了吧，如果是json数据，那么挨个循环，只取他们的name属性和value属性拼接字符串。 如果是普通对象，循环该对象的属性，然后拼接字符串。 总结： 所以，本文要说的是，在jquery的ajax函数中，可以传入3种类型的数据 1.文本：”uname=alice&amp;mobileIpt=110&amp;birthday=1983-05-12” 2.json对象：{uanme:’vic’,mobileIpt:’110’,birthday:’2013-11-11’} 3.json数组： 12345[ &#123;"name":"uname","value":"alice"&#125;, &#123;"name":"mobileIpt","value":"110"&#125;, &#123;"name":"birthday","value":"2012-11-11"&#125;] 所以，我们可以一键获取表单并提交，非常方便。 补充： 其实提取表单数据的话只需要 serialize() 方法直接获取 &quot;uname=alice&amp;mobileIpt=110&amp;birthday=1983-05-12&quot; 这样的就可以了。 转自:http://www.cnblogs.com/haitao-fan/p/3908973.html]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJs 实现简单服务器]]></title>
    <url>%2F2017%2F06%2F30%2Fnodejs-20170630NodeJs-%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[实现模拟一个可交互的简单服务器使用 NodeJS 来实现一个简单的服务器, 模拟一个接口,前端进行数据交互后,会再服务器本地新建一个 json 格式的文件用来存储 data. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var express = require('express');var bodyParser = require('body-parser');var fs = require('fs');var path = require('path');var app = express();var COMMENTS_FILE = path.join(__dirname,'dataFile/comments.json');app.set('port',(process.env.PORT || 8000));app.use('/', express.static(path.join(__dirname, 'dist')));app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123;extended: true&#125;));app.use(function(req,res,next)&#123; res.setHeader('Access-Control-Allow-Origin','*'); res.setHeader('Cache-Control','no-cache'); next();&#125;);app.get('/data/comments', function(req, res) &#123; fs.readFile(COMMENTS_FILE, function(err, data) &#123; if (err) &#123; console.error(err); process.exit(1); &#125; res.json(JSON.parse(data)); &#125;);&#125;);app.post('/data/comments', function(req, res) &#123; fs.readFile(COMMENTS_FILE, function(err, data) &#123; if (err) &#123; console.error(err); process.exit(1); &#125; var comments = JSON.parse(data); var newComment = &#123; id: Date.now(), author: req.body.author, text: req.body.text, &#125;; comments.push(newComment); fs.writeFile(COMMENTS_FILE, JSON.stringify(comments, null, 4), function(err) &#123; if (err) &#123; console.error(err); process.exit(1); &#125; res.json(comments); &#125;); &#125;);&#125;);app.listen(app.get('port'),function()&#123; console.log('Server started: http:127.0.0.1:' + app.get('port') + '');&#125;); 实现访问本地静态资源文件的简单服务器新建一个名称为 server 的文件夹,里面放置服务器端的文件。然后在这个文件夹中新建 server.js 文件,代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153module.exports = (function () &#123; "use strict"; console.time("[HttpServer][Start]"); // http 协议模块 var http = require('http'); // url 解析模块 var url = require('url'); // 文件系统模块 var fs = require('fs'); // 路径解析模块 var path = require('path'); // 服务器js 上一层目录 var dirname = path.dirname(__dirname); var httpSrc = ''; return &#123; // 启动服务 start: function ( src ) &#123; src &amp;&amp; (httpSrc = path.join(dirname, src)); var port = this.config.port; var ip = this.config.ip; // 创建一个服务 var httpServer = http.createServer(this.processRequest.bind(this)); // 在指定的端口监听服务 httpServer.listen(port, function () &#123; console.log("[HttpServer][Start]", "runing at http://" + ip + ":" + port + "/"); console.timeEnd("[HttpServer][Start]"); &#125;); httpServer.on("error", function ( error ) &#123; console.error(error); &#125;); &#125;, processRequest: function ( request, response ) &#123; var hasExt = true; var requestUrl = request.url; var pathName = url.parse(requestUrl).pathname; // 对请求的路径进行解码，防止中文乱码 pathName = decodeURI(pathName); //如果路径中没有扩展名 if (path.extname(pathName) === '') &#123; // 如果不是以 / 结尾的， 加 / 并作301重定向 if (pathName.charAt(pathName.length - 1) != '/') &#123; pathName += '/'; var redirect = 'http://' + request.headers.host + pathName; response.writeHead(301, &#123; location: redirect &#125;); response.end(); &#125; // 添加默认的访问页面，但这个页面不一定存在，后面会处理 pathName += 'index.html'; hasExt = false; // 标记默认页面是程序自动添加的 &#125; // 获取资源文件的相对路径 'http/webroot' var filePath = path.join(httpSrc || __dirname, pathName); // 获取对应文件的文档类型 var contentType = this.getContentType(filePath); // 如果文件名存在 fs.exists(filePath, function ( exists ) &#123; if (exists) &#123; response.writeHead(200, &#123; "content-type": contentType &#125;); var stream = fs.createReadStream(filePath, &#123; flags: "r", encoding: null, &#125;); stream.on("error", function () &#123; response.writeHead(500, &#123; "content-type": "text/html" &#125;); response.end("&lt;h1&gt;500 Server Error&lt;/h1&gt;"); &#125;); // 返回文件内容 stream.pipe(response); &#125; else &#123; // 文件名不存在的情况 if (hasExt) &#123; // 如果这个文件不是程序自动添加的，直接返回404 response.writeHead(404, &#123; "content-type": "text/html" &#125;); response.end("&lt;h1&gt;404 Not Found&lt;/h1&gt;"); &#125; else &#123; // 如果文件是程序自动添加的且不存在，则表示用户希望访问的是该目录下的文件列表 var html = '&lt;head&gt;&lt;meta charset="urf-8"&gt;&lt;/head&gt;'; try &#123; // 用户访问目录 var filedir = filePath.substring(0, filePath.lastIndexOf('\\')); // 获取用户访问路径下的文件列表 var files = fs.readdirSync(filedir); // 将访问路径下的所有文件一一列举出来，并添加超链接，以便用户进一步访问 for (var i in files) &#123; var filename = files[i]; html += '&lt;div&gt;&lt;a href="' + filename + '"&gt;' + filename + '&lt;/a&gt;&lt;/div&gt;'; &#125; &#125; catch (e) &#123; console.log('server running url is ' + filePath); html += '&lt;h1&gt;您访问的目录不存在&lt;/h1&gt;'; &#125; response.writeHead(200, &#123; "content-type": "text/html" &#125;); response.end(html); &#125; &#125; &#125;); &#125;, getContentType: function ( filePath ) &#123; var contentType = this.config.mime; var ext = path.extname(filePath).substr(1); if (contentType.hasOwnProperty(ext)) &#123; return contentType[ext]; &#125; else &#123; return contentType.default; &#125; &#125;, config: &#123; port: 1993, ip: '127.0.0.1', mime: &#123; "css": "text/css", "gif": "image/gif", "html": "text/html", "ico": "image/x-icon", "jpeg": "image/jpeg", "jpg": "image/jpeg", "js": "text/javascript", "json": "application/json", "pdf": "application/pdf", "png": "image/png", "svg": "image/svg+xml", "swf": "application/x-shockwave-flash", "tiff": "image/tiff", "txt": "text/plain", "wav": "audio/x-wav", "wma": "audio/x-ms-wma", "wmv": "video/x-ms-wmv", "xml": "text/xml" &#125; &#125; &#125;&#125;)(); 然后再在这个文件夹中新建一个 start.js 文件, 代码如下: 1require('./server.js').start('./src'); 上面的 require(&#39;./server.js&#39;) 则是上面新建的服务器文件, start() 方法则是启动服务的函数,里面的 ‘./src’ 则是项目根目录下的 ‘src’ 目录,该目录用来存放项目的所有文件,比如 html 、 css 、 js 和图片等文件。]]></content>
      <categories>
        <category>NodeJs</category>
      </categories>
      <tags>
        <tag>NodeJs</tag>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular directive 各属性详解]]></title>
    <url>%2F2017%2F06%2F29%2Fangularjs-20170629Angular-directive-%E5%90%84%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[准备实例代码 1var app = angular.module('app', []); angular指令定义大致如下 12345app.directive('directiveName', function() &#123; return &#123; // config &#125;&#125;) 其中return返回的配置对象包含很多参数，如下一一说明。 restrict值为字符串，可选参数，指明指令在DOM中以什么形式被声明 1234567891011&lt;!-- E (element) --&gt;&lt;directiveName&gt;&lt;/directiveName&gt;&lt;!-- A (attribute) --&gt;&lt;div directiveName="expression"&gt;&lt;/div&gt;&lt;!-- C (class) --&gt;&lt;div class="directiveName"&gt;&lt;/div&gt;&lt;!-- M(comment) --&gt;&lt;!--directive:directiveName expression--&gt; 默认值为 restrict: &#39;EA&#39; ，表示可以在DOM里面可以用元素形式和属性形式被声明。一般来说，如果你想创建一个自己模板的组件时，则使用元素形式，但是仅仅是为已有元素添加功能的话，就使用属性名。 如果想要支持IE8，则最好使用属性和类形式来定义，另外从angular 1.3.X开始，已经放弃支持IE8了。 priority数字，可选参数，致命指令的优先级，若在单个DOM元素上有多个指令，则优先级高的先执行。 当然，设置指令的优先级不太常用，但是比较特殊的例子是，内置指令ng-repeat的优先级为1000，而ng-init的优先级为 450。 terminal布尔型，可选参数，可以被设置为true或者false，若设置为true，则优先级低于此指令的其他指令则无效，不会被调用优先级相同任然会执行。 template字符串或者函数，可选参数。 可以是一段html文本 12345app.directive('hello', function() &#123; return &#123; template: '&lt;div&gt;&lt;h3&gt;Hello, world!&lt;/h3&gt;&lt;/div&gt;' &#125;&#125;) 使用如下 1&lt;hello&gt;&lt;/hello&gt; 渲染结果为 12345&lt;hello&gt; &lt;div&gt; &lt;h3&gt;Hello, world!&lt;/h3&gt; &lt;/div&gt;&lt;/hello&gt; 也可以是一个函数，可接受两个参数Element与Attrs 其中Element是指使用此指令的元素，而Attrs则是实例的属性，它是由一个元素上所有属性组成的集合，形如 1234567&#123; title: &apos;test&apos;, id: &apos;testDiv&apos;, &quot;class&quot;: &apos;demo&apos;, input: &apos;text&apos;, ...&#125; 下面让我们看看template是一个函数时的情况 1234567app.directive('hello', function() &#123; return &#123; template: function(element, attrs) &#123; return '&lt;div&gt;'+ attrs.title +'&lt;/div&gt;' &#125; &#125;;&#125;); html代码 1&lt;hello title="message"&gt;&lt;/hello&gt; 渲染结果 123&lt;hello&gt; &lt;div&gt;message&lt;/div&gt;&lt;/hello&gt; 实例地址 replace布尔型，默认值为false，设置为true的时候，表示可以用模板内容替换自定义的元素标签。 在template的例子中，我们发现渲染结果中包含有自定义的元素，很显然，这并不是我们想要的渲染结果，因此将replace设置为true之后，hello标签将会消失 12345678app.directive('hello', function() &#123; return &#123; replace: true, template: function(element, attrs) &#123; return '&lt;div&gt;'+ attrs.title +'&lt;/div&gt;' &#125; &#125;;&#125;); 渲染结果如下，hello标签消失不见 1&lt;div&gt;message&lt;/div&gt; templateUrl字符串或者函数，可选参数 可以使一个代表html文件路径的字符串，也可以是一个函数，大致意思与template一样。 在本地开发时，需要运行一个服务器，不然使用templateUrl会报错 1Cross origin request script(cors) 由于加载html模板是通过异步加载，若加载大量的模板会拖慢网站的速度，这里有一个技巧，就是先缓存模板，你可以先在你的index页面加载好，将下列代码作为你页面的一部分包含在内 123&lt;script type="text/ng-template" id="demo.html"&gt; &lt;div&gt;&lt;!--这里是模板内容--&gt;&lt;/div&gt;&lt;/script&gt; 这里的id属性就是被设置在templateUrl上用的 另外一种方法缓存如下 123app.run(function($templateCache) &#123; $templateCache.put('template.html', '&lt;div&gt;template&lt;/div&gt;');&#125;) scope布尔值或者对象，可选参数，默认值为false，表示继承父级作用域。 如果值为true，表示继承父作用域，并创建自己的作用域（子作用域） 如果为对象， {} ，则表示创建一个全新的隔离作用域。 首先我们需要来了解一下 scope 的继承机制。我们使用ng-controller这个指令来举例。我们都知道ng-controller可以从父作用域中继承并创建一个新的子作用域。如下： 1234567&lt;div ng-app=&quot;app&quot; ng-init=&quot;aaa=&apos;parent&apos;&quot;&gt; parentNode: &#123;&#123;aaa&#125;&#125; &lt;div ng-controller=&quot;demoController&quot;&gt; childrenNode: &#123;&#123;aaa&#125;&#125; &lt;/div&gt;&lt;/div&gt; 1234angular.module('app', []).controller('demoController', function($scope) &#123; $scope.aaa = "children";&#125;) 实例地址 这时页面的显示结果为 12parentNode: parentchildrenNode: children 当时当我们并没有在demoController的作用域中给aaa赋值，也就是在上例中删除这一句$scope.aaa = “children”;，那么执行结果就为 12parentNode: parentchildrenNode: parent 注意：如果一个元素上有多个指令都使用了隔离作用域，那么只有其中一个可以生效，只有指令模板中的根元素才能获得一个新的作用域，这时候，scope就被设置为true了。 1234567891011&lt;div ng-app=&quot;app&quot; ng-init=&quot;aaa=&apos;parent&apos;&quot;&gt; parentNode: &#123;&#123;aaa&#125;&#125; &lt;div ng-controller=&quot;demoController01&quot;&gt; childrenNode: &#123;&#123;aaa&#125;&#125; &lt;div ng-controller=&quot;demoController02&quot;&gt; lastNode: &#123;&#123;aaa&#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 1234567angular.module('app', []).controller('demoController01', function($scope) &#123; $scope.aaa = "children";&#125;).controller('demoController02', function($scope) &#123; $scope.aaa = "last"&#125;) 实例地址 接下来，我们通过一个简单明了的例子来说明scope取值的不同差别 123456&lt;div ng-app="app" ng-controller="mainController"&gt; parent: &#123;&#123; name &#125;&#125; &lt;br /&gt; &lt;input type="text" ng-model="name" /&gt; &lt;div my-directive&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617angular.module('app', []).controller('mainController', function($scope) &#123; $scope.name = "Jake";&#125;).directive('myDirective', function() &#123; return &#123; restrict: 'EA', scope: false, replace: true, template: '' + '&lt;div&gt;' + 'childNode: &#123;&#123; name &#125;&#125; ' + '&lt;br /&gt;' + '&lt;input type="text" ng-model="name"&gt;' + '&lt;/div&gt;' &#125;&#125;) 实例地址 点击上面的实例地址，我们可以依次改变scope的值为false, true, {}，结果发现 false：儿子继承父亲的值，改变父亲的值，儿子的值也随着改变，反之亦然，这就是继承且不隔离 true：儿子继承父亲的值，改变父亲的值，儿子的值也随着改变，但是改变儿子的值，父亲的值并没有改变，这就是继承但是隔离 {}：没有继承父亲的值，所以儿子的值为空，改变任何一方的值都不会影响另一方，这就是不继承且隔离 当想要创建一个可重用的组件时，隔离作用域是一个很好的选择，通过隔离作用域，我们可以确保指令是独立的，并且可以轻松的插入到任何HTML APP中，并且这种做法防止了父作用域被污染。 隔离作用域可以通过绑定策略来访问父作用域的属性 我们来看一个例子 1234&lt;div ng-app="app" ng-controller="mainController"&gt; &lt;input type="text" ng-model="color" placeholder="Enter a color"/&gt; &lt;hello-world&gt;&lt;/hello-world&gt;&lt;/div&gt; 1234567891011angular.module('app', []).controller('mainController', function($scope) &#123;&#125;).directive('helloWorld', function() &#123; return &#123; restrict: 'EA', scope: false, replace: true, template: '&lt;p style="background-color:&#123;&#123;color&#125;&#125;"&gt;Hello world!&lt;/p&gt;' &#125;&#125;) 运行上面的代码，我们在input中输入颜色值，比如red，那么hello world一行的背景就会变成红色。动手试试！ 实例地址 但是，当我们将scope的值设置为{}时，再次运行代码就发现页面并不能成功的完整显示了.这是因为{}让helloWorld指令产生了隔离作用域，没办法从父级作用域中继承到color的值了。 所以在template中的变成了依赖于自己的作用域，而不是依赖于父级作用域。因此我们需要一些办法来让隔离作用域能够读取父级作用域的属性，这个方法就是绑定策略。 下面我们来探索设置这种绑定策略的几种方法 方法一 使用@来进行单向文本（字符串）绑定 1234&lt;div ng-app="app" ng-controller="mainController"&gt; &lt;input type="text" ng-model="color" placeholder="Enter a color"/&gt; &lt;hello-world color-attr="&#123;&#123;color&#125;&#125;"&gt;&lt;/hello-world&gt;&lt;/div&gt; 12345678910111213angular.module('app', []).controller('mainController', function($scope) &#123;&#125;).directive('helloWorld', function() &#123; return &#123; restrict: 'EA', scope: &#123; color: '@colorAttr' &#125;, replace: true, template: '&lt;p style="background-color:&#123;&#123;color&#125;&#125;"&gt;Hello world!&lt;/p&gt;' &#125;&#125;) 实例地址 这种办法只能单向，通过在运行的指令DOM上设置 color-attr 属性，并且采用双花括号绑定某个模型值。当然，我们也可以直接在这里绑定字符串的颜色值，如 color-attr=&quot;red&quot;. 因此当表达式的值发生变化时，属性color-attr的值也会发生变化，通过单向绑定该值，就可以改变隔离作用域中的属性color. 123456789101112如果绑定的隔离作用域属性名与元素的属性名相同，则可以采用缺省写法 // html &lt;hello-world color=&quot;&#123;&#123;color&#125;&#125;&quot;&gt;&lt;/hello-world&gt; // js app.directive(&apos;helloWorld&apos;, function() &#123; return &#123; scope: &#123; color: &apos;@&apos; &#125;, ... &#125; &#125;) 方法二、使用’=’进行双向绑定 1234567&lt;div ng-app="app" ng-controller="mainController"&gt; &lt;input type="text" ng-model="color" placeholder="Enter a color"/&gt; &lt;br /&gt; &#123;&#123; color &#125;&#125; &lt;!-- 这里要注意写法与@绑定的不同 --&gt; &lt;hello-world color="color"&gt;&lt;/hello-world&gt;&lt;/div&gt; 1234567891011121314151617angular.module('app', []).controller('mainController', function($scope) &#123; $scope.color = 'red';&#125;).directive('helloWorld', function() &#123; return &#123; restrict: 'EA', scope: &#123; color: '=' &#125;, replace: true, template: '&lt;div&gt;&lt;p style="background-color:&#123;&#123;color&#125;&#125;"&gt;' + 'Hello world!' + '&lt;/p&gt;' + '&lt;input type="text" ng-model="color"&gt;&lt;/div&gt;' &#125;&#125;) 实例地址 此处也采用了类似的缺省写法。 这里需要注意的是，我们要直接在指令元素设置属性时，是直接将实际的作用域模型复制给该属性 这样一个双向绑定被建立了，改变任何一个input值都会改变另外一个值。 方法三、使用’&amp;’调用父作用域中的函数 123456&lt;div ng-app="app" ng-controller="mainController"&gt; &lt;input type="text" ng-model="name" placeholder="Enter name"/&gt; &lt;br /&gt; &#123;&#123; name &#125;&#125; &lt;hello-world say="say()" name="&#123;&#123;name&#125;&#125;"&gt;&lt;/hello-world&gt;&lt;/div&gt; 123456789101112131415161718angular.module('app', []).controller('mainController', function($scope) &#123; $scope.name = "yangbo"; $scope.say = function() &#123; alert('hello!'); &#125;&#125;).directive('helloWorld', function() &#123; return &#123; restrict: 'EA', scope: &#123; name: '@', say: '&amp;' &#125;, replace: true, template: '&lt;button type="button" ng-bind="name" ng-init="say()"&gt;&lt;/button&gt;' &#125;&#125;) 实例地址 同样采用了缺省写法，运行之后，弹出窗口！ transclude布尔值或者字符 element ，默认值为 false 这个配置选项可以让我们提取包含在指令那个元素里面的内容，再将它放置在指令模板的特定位置。当我们开启 transclude 之后，我们就可以使用 ng-transclude 来指明应该在什么地方放置 transclude 的内容 12345678&lt;div ng-app="app" ng-controller="mainController"&gt; &lt;div class="a"&gt; &lt;p&gt;china&lt;/p&gt; &lt;hello-world&gt; &#123;&#123;name&#125;&#125; &lt;/hello-world&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213angular.module('app', []).controller('mainController', function($scope) &#123; $scope.name = "yangbo5207";&#125;).directive('helloWorld', function() &#123; return &#123; restrict: 'EA', scope: &#123;&#125;, replace: true, transclude: true, template: '&lt;div class="b"&gt;&lt;div ng-transclude&gt;你看不见我&lt;/div&gt;&lt;/div&gt;' &#125;&#125;) 运行上面的代码，输出 12chinayangbo5207 我们查看渲染出来的html，结果为 12345678910&lt;div ng-app="app" ng-controller="mainController" class="ng-scope"&gt; &lt;div class="a"&gt; &lt;p&gt;china&lt;/p&gt; &lt;div class="b ng-isolate-scope"&gt; &lt;div ng-transclude=""&gt; &lt;span class="ng-binding ng-scope"&gt;yangbo5207&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 另外当开启 transclude 时，会创建一个新的 transclude 空间，并且继承父作用域（也就是 scope 设置的隔离作用域） 从上面例子我们知道，当 transclude 的值被设置为 true 时，嵌入的内容为，但是如果将它的值设置为 element 呢，我们可以在上例的基础上进行一个简单的修改，发现，嵌入内容为整个元素 注意：在一个指令的模板中，只能声明一次ng-transclude 那么问题来了，如果我们想要把嵌入内容多次放入我们的模板中怎么办？ 可以使用 $transclude ，后面会讲到！也可以使用 complie 函数中，里面的 transcludeFn 参数，后面会讲到！或者使用link连接函数 controller可以是一个字符串或者函数。 若为字符串，则将字符串当做控制器的名字，来查找注册在应用中的控制器的构造函数 1234567891011121314angular.module('app', []).directive('myDirective', function() &#123; return &#123; restrict: 'EA', replace: true, transclude: true, // 会查找模块中其他被名为targetController的控制器 controller: 'targetController' &#125;&#125;).controller('targetController', function($scope, $element, $attrs, $transclude) &#123; // 控制器逻辑放在这里&#125;) 当然，也可以直接在指令内部定义为匿名函数，同样可以注入任何服务 1234567891011angular.module('app', []).directive('myDirective', function() &#123; return &#123; restrict: 'EA', replace: true, transclude: true, controller: function($scope, $element, $attrs, $transclude) &#123; // 控制器逻辑 &#125; &#125;&#125;) 另外还有一些特殊的服务可以注入， $scope 与指令元素相关联的作用域 $element 当前指令对应的元素 $attrs 当前元素的属性组成的对象 $transclude 嵌入链接函数，实际被执行用来克隆元素和操作DOM中的函数（除非是用来定义一些可复用的行为，否则一般不推荐在这使用） 指令的控制器和link函数（后面会讲到）可以进行互换。区别在于，控制器主要用来提供可在指令间复用的行为，可对外提供与外部交互的接口，但是link链接只能在当前指令内部中定义行为，且无法在指令间复用。 123&lt;div ng-app="app"&gt; &lt;div test-directive="dateType" url="http://www.tigerbrokers.com"&gt;外面的世界很精彩。&lt;/div&gt;&lt;/div&gt; 123456789101112131415angular.module('app', []).directive('testDirective', function() &#123; return &#123; transclude: true, replace: true, controller: function($scope, $element, $attrs, $transclude, $log) &#123; $transclude(function(clone) &#123; var a = angular.element('&lt;a&gt;'); a.attr('href', $attrs.url); a.text(clone.text()); $element.append(a); &#125;); &#125; &#125;&#125;) 实例地址 $transclude 可以接受两个参数，第一个是$scope，第二个是才有参数clone的回调函数。 而这个clone实际上就是嵌入的内容。可以在根据它做很多DOM操作。 它还有最简单的用法 12345678910111213angular.module('app', []).directive('testDirective', function() &#123; return &#123; transclude: true, replace: true, controller: function($scope, $element, $attrs, $transclude, $log) &#123; // 这里的$transclude就是嵌入的内容 var a = $transclude(); $element.append(a); &#125; &#125;&#125;) 但是我们要注意，使用 $transclude 会生成一个新的作用域。默认情况下，如果我们简单使用 $transclude() ，那么其作用域就是 $transclude 生成的作用域。但是如果我们使用 $transclude($scope, function(clone) {}) ，那么作用域就是 directive 的作用域了。 当然问题又来了，如果我们想使用父级作用域呢？ 1$scope.$parent 12345&lt;div ng-app="app" ng-controller="parentController"&gt; &lt;div ng-controller="sonController"&gt; &lt;test-directive url="http://www.tigerbrokers.com"&gt;炒美股，上老虎2&lt;/test-directive&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021angular.module('app', []).controller('parentController', function($scope) &#123; $scope.title = "PARENT TIGER";&#125;).controller('sonController', function($scope) &#123; $scope.title = "CHILDREN TIGER";&#125;).directive('testDirective', function() &#123; return &#123; transclude: true, replace: true, controller: function($scope, $element, $attrs, $transclude, $log) &#123; var a = $transclude(); $element.append(a); $log.info($scope.title); $log.info($scope.$parent.title); &#125; &#125;&#125;) 实例地址 controllerAsangualr 1.2之后，就已经开始支持controllerAs的语法，这样我们就可以不用将属性和方法挂载到$scope上，而是this上。 1&lt;div ng-app="app" ng-controller="demoController as demo"&gt;&#123;&#123; demo.name &#125;&#125;&lt;/div&gt; 1234angular.module('app', []).controller('demoController', function() &#123; this.name = "Jake";&#125;) 实例地址 我们可以从实例中看出，这里的 this 就是指的 as 后面的那个别名。然后我们在表达式中就可以使用这个别名 我们知道，在 directive 中的 controller ，主要职能是对外提供交互接口，而结合 require 与 link ，因此我们常常会利用这样的语法而非上面例子中的 $scope. 1234567app.directive('testDirective', function() &#123; return &#123; controller: function() &#123; this.name = "Jake"; &#125; &#125;&#125;) require字符串或者数组，字符串代表另一个指令的名字，它将作为 link 函数的第四个参数。具体用法我们可以举例子来说明。 假设现在我们要编写两个指令，两个指令的 link 函数中存在许多重合的方法，这时候我们就可以将这些重复的方法写在第三个指令的 controller 中，然后在这两个指令中，使用 require 将第三个指令引入进来，然后我们就可以通过 link 连接函数的第四个参数引用这些重合的方法了 指令之间常常通过这种方式进行交互 1234567&lt;div ng-app="expanderModule" ng-controller="SomeController" class="wrap"&gt; &lt;accordion&gt; &lt;expander class='expander' ng-repeat='expander in expanders' expander-title='expander.title'&gt; &#123;&#123;expander.text&#125;&#125; &lt;/expander&gt; &lt;/accordion&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var expModule=angular.module('expanderModule',[])expModule.directive('accordion', function() &#123; return &#123; restrict : 'EA', replace : true, transclude : true, template : '&lt;div ng-transclude&gt;&lt;/div&gt;', controller : function() &#123; var expanders = []; this.gotOpened = function(selectedExpander) &#123; angular.forEach(expanders, function(expander) &#123; if (selectedExpander != expander) &#123; expander.showMe = false; &#125; &#125;); &#125; this.addExpander = function(expander) &#123; expanders.push(expander); &#125; &#125; &#125;&#125;);expModule.directive('expander', function() &#123; return &#123; restrict : 'EA', replace : true, transclude : true, require : '^?accordion', scope : &#123; title : '=expanderTitle' &#125;, template : '&lt;div&gt;' + '&lt;div class="title" ng-click="toggle()"&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;' + '&lt;div class="body" ng-show="showMe" ng-transclude&gt;&lt;/div&gt;' + '&lt;/div&gt;', link : function(scope, element, attrs, accordionController) &#123; scope.showMe = false; accordionController.addExpander(scope); scope.toggle = function toggle() &#123; scope.showMe = !scope.showMe; accordionController.gotOpened(scope); &#125; &#125; &#125;&#125;);expModule.controller("SomeController",function($scope) &#123; $scope.expanders = [&#123; title : 'Click me to expand', text : 'Hi there folks, I am the content that was hidden but is now shown.' &#125;, &#123; title : 'Click this', text : 'I am even better text than you have seen previously' &#125;, &#123; title : 'Test', text : 'test' &#125;];&#125;); 实例地址 实例说明， controller 是用来与不同指令之间通信的。 另外我们可以在 require 的参数值加上下面的某个前缀，这回改变查找控制器的行为。 没有前缀 指令会在自身提供的控制器中进行查找，如果找不到任何控制器，则会抛出一个error ? 若在当前指令中没有找到所需的控制器，则会将null传给link链接函数的第四个参数 ^ 如果在当前的指令中没有找到所需的控制器，则会查找父元素的控制器 ?^ 如果在当前和父元素中都没有找到控制器，则会将null传给link angular指令编译过程首先加载 angular 库，查找 ng-app 指令，从而找到应用的边界，根据 ng-app 划定的作用域来调用 $compile 服务进行编译。 angular 会遍历整个 html 文档，并根据 js 中指令的定义来处理在页面上声明的各个指令，按照指令的优先级排列，根据指令中的配置参数( template , replace, transclude等)转换DOM，然后就开始按照顺序执行各指令的 compile 函数（如果指令上有定义 compile 函数）对模板自身进行转换。 此处的compile函数值什么指令中配置的，与上面说的$compile服务不一样 每个compile函数执行完后会返回一个link函数，所有的link函数会合成一个大的link函数，然后这个大的link函数就会被执行， 主要做数据绑定，通过 DOM上注册监听器来动态修改scope中的数据，或者是使用$watchs监听scope中变量来修改DOM，从而建立双向绑定等等。 若我们的指令中没有配置compile函数，那我们配置的link函数就会运行，她做的事情大致跟上面compile返回之后所有的link合成的大link函数差不多。 所以，在指令中compile与link选项是互斥的，如果同时设置了这两项，那么就会把compile所返回的函数当做是链接函数，而link选项本身会被忽略。 compile编译函数与link链接函数cmopile选项可以返回一个对象或者函数，在这里我们可以在指令和实时数据被放到DOM之前进行DOM操作，比如我们可以在这里进行添加或者删除节点的DOM操作。 所以编译函数是负责对模板的DOM进行转换，并且仅仅只会运行一次 1234567//compile函数的语法compile:function compile(tElement,tAttrs,transclude)&#123; return&#123; pre:function preLink(scope,iElement,iAttrs,controller)&#123;&#125;, post:function postLink(scope,iElement,iAttrs,controller)&#123;&#125; &#125; &#125; 对于我们编写的大部分指令来说，并不需要对模板进行转换，所以大部分情况只需要编写link函数就行。 preLink函数会在编译阶段之后，指令链接到子元素之前执行，类似的，postLink会在指令链接到子元素之后执行。这意味着，为了不破坏绑定过程，如果你需要修改DOM结构，你应该在postLink函数中来做这件事情。 link函数负责将作用域与DOM进行链接 12//link链接函数link:function postLink(scope,iElement,iAttrs)&#123;&#125; 若指令中定义有require选项，则link函数会有第四个参数，代表控制器或者所依赖的指令的控制器（上面require选项例子已有例子） 转载来自 https://segmentfault.com/a/1190000005851663#articleHeader12]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>directive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端跨域整理]]></title>
    <url>%2F2017%2F06%2F27%2Fother-20170627%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[跨域资源共享 CORS对于web开发来讲，由于浏览器的同源策略，我们需要经常使用一些 hack 的方法去跨域获取资源，但是hack的方法总归是hack。直到W3C出了一个标准－CORS－”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。 首先来说 CORS 需要浏览器和服务端同时支持的，对于兼容性来说主要是 ie10+ ，其它现代浏览器都是支持的。 https://caniuse.com/#feat=cors 使用 CORS 跨域的时候其实和普通的 ajax 过程是一样的，只是浏览器在发现这是一个跨域请求的时候会自动帮我们处理一些事，比如验证等等，所以说只要服务端提供支持，前端是不需要做额外的事情的。 两种请求CORS 的请求分两种，这也是浏览器为了安全做的一些处理，不同情况下浏览器执行的操作也是不一样的，主要分为两种请求，当然这一切我们是不需要做额外处理的，浏览器会自动处理的。 简单请求（simple request）只要同时满足以下两大条件，就属于简单请求。 条件12345678910111) 请求方法是以下三种方法中的一个：HEADGETPOST2）HTTP的头信息不超出以下几种字段：AcceptAccept-LanguageContent-LanguageLast-Event-IDContent-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 过程对于简单的跨域请求，浏览器会自动在请求的头信息加上 Origin 字段，表示本次请求来自哪个源（协议 + 域名 + 端口），服务端会获取到这个值，然后判断是否同意这次请求并返回。 1234567// 请求GET /cors HTTP/1.1Origin: https://api.qiutc.meHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 1.服务端允许如果服务端许可本次请求，就会在返回的头信息多出几个字段： 12345// 返回Access-Control-Allow-Origin: https://api.qiutc.meAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: InfoContent-Type: text/html; charset=utf-8 这三个带有 Access-Control 开头的字段分别表示： 1.Access-Control-Allow-Origin必须。它的值是请求时Origin字段的值或者 *，表示接受任意域名的请求。 2.Access-Control-Allow-Credentials；可选。它的值是一个布尔值，表示是否允许发送 Cookie 。默认情况下， Cookie 不包括在 CORS 请求之中。设为 true ，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。再需要发送 cookie 的时候还需要注意要在 AJAX 请求中打开 withCredentials 属性： var xhr = new XMLHttpRequest(); xhr.withCredentials = true;需要注意的是，如果要发送 Cookie ， Access-Control-Allow-Origin 就不能设为 * ，必须指定明确的、与请求网页一致的域名。同时， Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且原网页代码中的 document.cookie 也无法读取服务器域名下的 Cookie 。 3.Access-Control-Expose-Headers可选。 CORS 请求时， XMLHttpRequest 对象的 getResponseHeader() 方法只能拿到6个基本字段： Cache-Control 、 Content-Language 、 Content-Type 、 Expires 、 Last-Modified 、 Pragma 。如果想拿到其他字段，就必须在 Access-Control-Expose-Headers 里面指定。上面的例子指定， getResponseHeader(&#39;Info&#39;) 可以返回Info字段的值。 2.服务端拒绝当然我们为了防止接口被乱调用，需要限制源，对于不允许的源，服务端还是会返回一个正常的HTTP回应，但是不会带上 Access-Control-Allow-Origin 字段，浏览器发现这个跨域请求的返回头信息没有该字段，就会抛出一个错误，会被 XMLHttpRequest 的 onerror 回调捕获到。这种错误无法通过 HTTP 状态码判断，因为回应的状态码有可能是 `200` 非简单请求条件出了简单请求以外的 CORS 请求。非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。 过程1）预检请求 非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为”预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错。预检请求的发送请求： 12345678OPTIONS /cors HTTP/1.1Origin: https://api.qiutc.meAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.qiutc.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... “预检”请求用的请求方法是 OPTIONS ，表示这个请求是用来询问的。头信息里面，关键字段是 Origin ，表示请求来自哪个源。除了 Origin 字段，”预检”请求的头信息包括两个特殊字段。 1.Access-Control-Request-Method该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是 PUT 。 2.Access-Control-Request-Headers该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是 X-Custom-Header 。预检请求的返回： 123456789101112HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: https://api.qiutc.meAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 3.Access-Control-Allow-Methods必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 4.Access-Control-Allow-Headers如果浏览器请求包括 Access-Control-Request-Headers 字段，则 Access-Control-Allow-Headers 字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 5.Access-Control-Max-Age该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 2）浏览器的正常请求和回应 一旦服务器通过了”预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个 Origin 头信息字段。服务器的回应，也都会有一个 Access-Control-Allow-Origin 头信息字段。 参考：《跨域资源共享 CORS 详解》 jsonpjsonp = json + padding其实对于常用性来说，jsonp应该是使用最经常的一种跨域方式了，他不受浏览器兼容性的限制。但是他也有他的局限性，只能发送 GET 请求，需要服务端和前端规定好，写法丑陋。它的原理在于浏览器请求 script 资源不受同源策略限制，并且请求到 script 资源后立即执行。主要做法是这样的： 1.在浏览器端： 首先全局注册一个callback回调函数，记住这个函数名字（比如：resolveJson），这个函数接受一个参数，参数是期望的到的服务端返回数据，函数的具体内容是处理这个数据。 然后动态生成一个 script 标签，src 为：请求资源的地址＋获取函数的字段名＋回调函数名称，这里的获取函数的字段名是要和服务端约定好的，是为了让服务端拿到回调函数名称。（如：www.qiute.com?callbackName=resolveJson）。 1234567function resolveJosn(result) &#123; console.log(result.name);&#125;var jsonpScript= document.createElement(&quot;script&quot;);jsonpScript.type = &quot;text/javascript&quot;;jsonpScript.src = &quot;https://www.qiute.com?callbackName=resolveJson&quot;;document.getElementsByTagName(&quot;head&quot;)[0].appendChild(jsonpScript); 2.服务端 在接受到浏览器端 script 的请求之后，从url的query的callbackName获取到回调函数的名字，例子中是resolveJson。 然后动态生成一段javascript片段去给这个函数传入参数执行这个函数。比如： 1resolveJson(&#123;name: 'qiutc'&#125;); 3.执行 服务端返回这个 script 之后，浏览器端获取到 script 资源，然后会立即执行这个 javascript，也就是上面那个片段。这样就能根据之前写好的回调函数处理这些数据了。 在一些第三方库往往都会封装jsonp的操作，比如 jQuery 的$.getJSON。 document.domain一个页面框架（iframe／frame）之间（父子或同辈），是能够获取到彼此的window对象的，但是这个 window 不能拿到方法和属性。 123456789// 当前页面域名 https://blog.qiutc.me/a.html&lt;script&gt;function onLoad() &#123; var iframe =document.getElementById(&apos;iframe&apos;); var iframeWindow = iframe.contentWindow; // 这里可以获取 iframe 里面 window 对象，但是几乎没用 var doc = iframeWindow.document; // 获取不到&#125;&lt;/script&gt;&lt;iframe src=&quot;https://www.qiutc.me/b.html&quot; onload=&quot;onLoad()&quot;&lt;/iframe&gt; 这个时候，document.domain 就可以派上用场了，我们只要把 https://blog.qiutc.me/a.html 和 https://www.qiutc.me/b.html 这两个页面的 document.domain 都设成相同的域名就可以了。前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致。但要注意的是，document.domain 的设置是有限制的，我们只能把 document.domain 设置成自身或更高一级的父域，且主域必须相同。例如：a.b.example.com 中某个文档的 document.domain 可以设成 a.b.example.com、b.example.com、example.com 中的任意一个，但是不可以设成 c.a.b.example.com,因为这是当前域的子域，也不可以设成baidu.com,因为主域已经不相同了。这样我们就可以通过js访问到iframe中的各种属性和对象了。 12345678910// 主页面：https://blog.qiutc.me/a.html&lt;script&gt;document.domain = &apos;qiutc.me&apos;;function onLoad() &#123; var iframe =document.getElementById(&apos;iframe&apos;); var iframeWindow = iframe.contentWindow; // 这里可以获取 iframe 里面 window 对象并且能得到方法和属性 var doc = iframeWindow.document; // 获取到&#125;&lt;/script&gt;&lt;iframe src=&quot;https://www.qiutc.me/b.html&quot; onload=&quot;onLoad()&quot;&lt;/iframe&gt; 1234// iframe 里面的页面&lt;script&gt;document.domain = &apos;qiutc.me&apos;;&lt;/script&gt; window.namewindow对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个 window.name 的，每个页面对 window.name 都有读写的权限，window.name 是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。比如有一个 www.qiutc.me/a.html 页面，需要通过 a.html 页面里的js来获取另一个位于不同域上的页面 www.qiutc.com/data.html 里的数据。data.html 页面里的代码很简单，就是给当前的 window.name 设置一个 a.html 页面想要得到的数据值。data.html 里的代码： 123&lt;script&gt;window.name = &apos;我是被期望得到的数据&apos;;&lt;/script&gt; 那么在 a.html 页面中，我们怎么把 data.html 页面载入进来呢？显然我们不能直接在 a.html 页面中通过改变 window.location 来载入 data.html 页面,因为我们想要即使 a.html 页面不跳转也能得到 data.html 里的数据。答案就是在 a.html 页面中使用一个隐藏的 iframe 来充当一个中间人角色，由 iframe 去获取 data.html 的数据，然后 a.html 再去得到 iframe 获取到的数据。充当中间人的 iframe 想要获取到 data.html 的通过 window.name 设置的数据，只需要把这个 iframe 的src设为 www.qiutc.com/data.html 就行了。然后 a.html 想要得到 iframe 所获取到的数据，也就是想要得到 iframe 的 window.name 的值，还必须把这个 iframe 的src设成跟 a.html 页面同一个域才行，不然根据前面讲的同源策略， a.html 是不能访问到 iframe 里的 window.name 属性的。这就是整个跨域过程。 1234567891011121314151617181920// a.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; function getData() &#123; var iframe =document.getElementById(&apos;iframe&apos;); iframe.onload = function() &#123; var data = iframe.contentWindow.name; // 得到 &#125; iframe.src = &apos;b.html&apos;; // 这里b和a同源 &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe src=&quot;https://www.qiutc.com/data.html&quot; style=&quot;display:none&quot; onload=&quot;getData()&quot;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; window.postMessagewindow.postMessage(message, targetOrigin) 方法是 html5 新引进的特性，可以使用它来向其它的 window 对象发送消息，无论这个 window 对象是属于同源或不同源。兼容性： http://caniuse.com/#search=postMessage 调用 postMessage 方法的 window 对象是指要接收消息的那一个 window 对象，该方法的第一个参数 message 为要发送的消息，类型只能为字符串；第二个参数 targetOrigin 用来限定接收消息的那个 window 对象所在的域，如果不想限定域，可以使用通配符 * 。需要接收消息的 window 对象，可是通过监听自身的 message 事件来获取传过来的消息，消息内容储存在该事件对象的data属性中。上面所说的向其他 window 对象发送消息，其实就是指一个页面有几个框架的那种情况，因为每一个框架都有一个 window 对象。在讨论第种方法的时候，我们说过，不同域的框架间是可以获取到对方的 window 对象的，虽然没什么用，但是有一个方法是可用的－ window.postMessage 。下面看一个简单的示例，有两个页面： 123456789// 主页面 blog.qiutc.com&lt;script&gt;function onLoad() &#123; var iframe =document.getElementById(&apos;iframe&apos;); var iframeWindow = iframe.contentWindow; iframeWindow.postMessage(&quot;I&apos;m message from main page.&quot;);&#125;&lt;/script&gt;&lt;iframe src=&quot;https://www.qiutc.me/b.html&quot; onload=&quot;onLoad()&quot;&lt;/iframe&gt; 1234567// b 页面&lt;script&gt;window.onmessage = function(e) &#123; e = e || event; console.log(e.data);&#125;&lt;/script&gt; CSST (CSS Text Transformation) 一种用 CSS 跨域传输文本的方案。优点：相比 JSONP 更为安全，不需要执行跨站脚本。缺点：没有 JSONP 适配广，CSST 依赖支持 CSS3 的浏览器。原理：通过读取 CSS3 content 属性获取传送内容。具体可以参考：CSST (CSS Text Transformation)]]></content>
      <categories>
        <category>跨域</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[$.ajax,$.post,$.get参数详解]]></title>
    <url>%2F2017%2F06%2F26%2Fjquery-20170626ajax-post-get%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[$.ajax,$.post,$.get参数详解 $.ajax(options); 参数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758url(String):发送请求的地址。type(String):默认: "GET") 请求方式 ("POST" 或 "GET")。async:true;默认为true，为异步请求，false为同步请求。beforeSend(function);发送请求前可修改 XMLHttpRequest 对象的函数。function(XMLHttpRequest)&#123; --this//&#125;cache:true;默认true,设置为false将不会从浏览器缓存中加载请求信息。complete(function);请求完成后回调函数。function (XMLHttpRequest, textStatus) &#123; this; // 调用本次AJAX请求时传递的options参数&#125;contentType:'application/x-www-form-urlencoded';发送信息至服务器时内容编码类型。data:&#123;value:'text'&#125;;发送到服务器的数据。dataFilter(function):给Ajax返回的原始数据的进行预处理的函数。function (data, type) &#123;// 对Ajax返回的原始数据进行预处理 return data // 返回处理后的数据&#125;dataType(String):预期服务器返回的数据类型。默认返回 responseXML 或 responseText。（xml,html,script,json,jsonp,text）。error(function);(默认: 自动判断 (xml 或 html)) 请求失败时调用.function (XMLHttpRequest, textStatus, errorThrown) &#123; // 通常 textStatus 和 errorThrown 之中 // 只有一个会包含信息 this; // 调用本次AJAX请求时传递的options参数&#125;success(function);请求成功后回调函数。参数：服务器返回数据，数据格式。function (data, textStatus) &#123; // data 可能是 xmlDoc, jsonObj, html, text, 等等... this; // 调用本次AJAX请求时传递的options参数&#125;username (String) : 用于响应HTTP访问认证请求的用户名timeout (Number) : 设置请求超时时间（毫秒）。此设置将覆盖全局设置。global (Boolean) : (默认: true) 是否触发全局 AJAX 事件。设置为 false 将不会触发全局 AJAX 事件。ifModified (Boolean) : (默认: false) 仅在服务器数据改变时获取新数据。使用 HTTP 包 Last-Modified 头信息判断。jsonp (String) : 在一个jsonp请求中重写回调函数的名字。这个值用来替代在"callback=?"这种GET或POST请求中URL参数里的"callback"部分，比如&#123;jsonp:'onJsonPLoad'&#125;会导致将"onJsonPLoad=?"传给服务器。password (String) : 用于响应HTTP访问认证请求的密码processData (Boolean) : (默认: true) 默认情况下，发送的数据将被转换为对象(技术上讲并非字符串) 以配合默认内容类型 "application/x-www-form-urlencoded"。如果要发送 DOM 树信息或其它不希望转换的信息，请设置为 false。scriptCharset (String) : 只有当请求时dataType为"jsonp"或"script"，并且type是"GET"才会用于强制修改charset。通常在本地和远程的内容编码不同时使用。 示例： 12345678$.ajax(&#123; type: "POST", url: "some.PHP", data: "name=John&amp;location=Boston", success: function(msg)&#123; alert( msg ); &#125;&#125;); $.post();参数1234567url:规定把请求发送到哪个 URL。data:请求发送到服务器的数据。dataType:服务器响应的数据类型，默认智能判断（xml,json,script,html）。success(data,textStatus,XHR):请求成功时执行的回调函数。 示例： 12345678910$.post(&#123; url:'test.html', data:&#123;value:'测试'&#125;, dataType:'json', function(data,textStatus,xhr)&#123; if(textStatus=='success')&#123; ---执行 &#125; &#125;&#125;); $.get();参数1234567url:请求发送的url。data:发送到服务器的数据。dataType:服务器响应数据类型；默认智能判断（xml,html,text,scritp,json,jsonp）success(response,status,xhr):回调函数，response-来自请求的结果数据；status-包含请求状态；xhr-包含XMLHttpRequest对象。 等价于： 1234567$.ajax(&#123; type: 'GET', url: url, data: data, success: success, dataType: dataType&#125;);]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git notes]]></title>
    <url>%2F2017%2F06%2F25%2Fgit-Git-Notes%2F</url>
    <content type="text"><![CDATA[本地上传（获取）远程仓库项目进入要上传的仓库，右键git bash，添加远程地址： 1$ git remote add origin git@github.com:yourname/yourRepo.git 修改远程仓库地址：12$ git remote rm origin //删除远程仓库地址$ git remote add origin git@github.com:yourname/yourRepo.git //重新添加新的远程仓库地址 将当前目录初始化为git 仓库1$ git init 提交、上传：接下来在本地仓库里添加一些文件，比如README，12$ git add README (上传单一文件) / $ git add . （上传所有新添加文件）$ git commit -m "first commit" //添加上传说明信息 创建分支查询当前仓库的所有分支，#标识为当前分支 1$ git branch 创建分支 1$ git branch [branchname] 切换分支 1$ git checkout [branchname] 简写方式：创建分支并切换到新建分支 1$ git checkout -b [branchname] 上传到github如果远程仓库是空的，则无需合并,直接上传（主干） 1$ git push origin master 如果远程仓库已有项目文件，则需要先合并，再上传（主干） 12$ git pull origin master$ git push origin master 克隆远程项目到本地进入到要托管的项目根目录， 右键启动Git Bash命令行； 输入git clone 接着将先前记录下来的地址复制到后面，回车 1$ git clone https://github.com/SYJUN/Test.git 将下载下来的项目文件夹的所有文件及文件夹，包括.git文件夹在内，全部拷贝到你的托管项目的根目录（或者将你的托管项目拷贝到该目录） 1$ cd Test // 进入到该托管项目的根目录 输入 git add . 将改动的地方添加到版本管理器 1$ git add . 输入 git commit -m “changes log” 提交到本地的版本控制库里，引号里面是你对本次提交的说明信息。 1$ git commit -m "changes log" 最后输入 git push -u origin master 将你本地的仓库提交到你的github账号里，此时会要求你输入你的github的账号和密码。 1$ git push -u origin master 删除/创建仓库中的文件/文件夹创建 12$ mkdir folderName &amp;&amp; cd folderName // 创建文件夹并进入该文件夹$ touch [filename] // 创建文件，需要添加相关文件类型扩展名 删除 – 在删除文件可以先pull远程仓库，然后再删除123456$ git pull (you git url)/(origin [branchname]/HEAD)$ git checkout$ rm -r dirName(需要删除的文件名)$ git add --all$ git commit -m"remove dir"$ git push (you git url)/(origin [branchname]/HEAD) 更改仓库1$ git remote set-url origin [repositoriesName] 新增（添加）远程仓库地址1$ git remote set-url --add all [https://bitbucket.org/SYJUN/guidemanual.git] 或者：直接修改.git文件夹中的config文件 获取本地 config 文件中的远程仓库地址12345$ git config --get remote.origin.url// 或者$ git remote -v // 列出每个链接的url链接 git 删除远程文件夹或文件的方法1234$ git rm -r -n --cached */src/\* //-n：加上这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。$ git rm -r --cached */src/\* //最终执行命令.$ git commit -m "移除src目录下所有文件的版本控制" //提交$ git push origin master //提交到远程服务器]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2F2017%2F06%2F25%2Fother-Hexo%2F</url>
    <content type="text"><![CDATA[Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
